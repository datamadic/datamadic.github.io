<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Where&#39;s the Any key?</title>
    <link>https://datamadic.github.io/posts/</link>
    <description>Recent content in Posts on Where&#39;s the Any key?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://datamadic.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Surfing With Clojure</title>
      <link>https://datamadic.github.io/posts/cn2020/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://datamadic.github.io/posts/cn2020/</guid>
      <description>I was honored to present at Clojure/north 2020. Due to Covid 19, it ended up being a virtual conference, but was a blast nonetheless as the organizers did a fantastic job pulling it all together.
The talk was centered around an application that I have been working on in my spare time which I call DeepSwell that allows me to better visualize the surf forecast for my local area. The basic idea is to continually monitor and record the forecasts provided by NOAA as well as video snippets from the surf cams for those times.</description>
    </item>
    
    <item>
      <title>Lazy</title>
      <link>https://datamadic.github.io/posts/lazy/</link>
      <pubDate>Fri, 03 Jul 2020 18:42:59 -0400</pubDate>
      
      <guid>https://datamadic.github.io/posts/lazy/</guid>
      <description>Most sequence functions in Clojure, such as map, range, filter and others, return lazy sequences. This can be used to write methods that take advantage of lazy sequences where you would normally reach for loops. The benefits typically associated with lazy sequences are
 Only calculating what you need when you need it (if ever) Being able to represent infinite sequences that would not fit in memory  After working with them a bit I&#39;d add</description>
    </item>
    
    <item>
      <title>( DFS )</title>
      <link>https://datamadic.github.io/posts/dfs/</link>
      <pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://datamadic.github.io/posts/dfs/</guid>
      <description>Useful for finding cycles and is often used as step in the process for things like topological sorts (as demonstrated below) and finding strongly connected components. DFS is generally run to learn about a graph&#39;s structure and, unlike BFS which is ordinarily seeded with a single root vertex, DFS will iterate over all vertices. The discovered and finished times have a parenthesis structure where the intervals \([d[u], f[u]] \:and\: [d[v], f[v]]\) are either entirely disjoint, or one is entirely contained within the other.</description>
    </item>
    
    <item>
      <title>( BFS )</title>
      <link>https://datamadic.github.io/posts/bfs/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://datamadic.github.io/posts/bfs/</guid>
      <description>Given a graph G = (V, E) and a distinguished vertex s, BFS explores the edges of G to discover every vertex that is reachable from s.
It computes the distance (smallest number of edges) from s to each reachable vertex.
It produces an breadth-first tree with root s that contains all reachable vertices. For any vertex v reachable from s, the path in the breadth-first tree from v to s corresponds to a shortest path from v to s in G.</description>
    </item>
    
  </channel>
</rss>