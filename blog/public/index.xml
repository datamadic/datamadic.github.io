<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Where&#39;s the Any key?</title>
    <link>https://datamadic.github.io/</link>
    <description>Recent content on Where&#39;s the Any key?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Jul 2020 23:07:50 -0400</lastBuildDate>
    
	<atom:link href="https://datamadic.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://datamadic.github.io/about/</link>
      <pubDate>Fri, 03 Jul 2020 23:07:50 -0400</pubDate>
      
      <guid>https://datamadic.github.io/about/</guid>
      <description>Here An attempt to write out some the topics I look into, mostly to help future me remember and to practice writing. As such, any coding examples are largely focused on the computations they perform and not friendly naming as you would expect in real code. Think an algo book&amp;rsquo;s psudo-code.
Also fair game here would be musings about random topics and things I want to remember.
Me Hi, I&amp;rsquo;m Xavier.</description>
    </item>
    
    <item>
      <title>Lazy</title>
      <link>https://datamadic.github.io/posts/lazy/</link>
      <pubDate>Fri, 03 Jul 2020 18:42:59 -0400</pubDate>
      
      <guid>https://datamadic.github.io/posts/lazy/</guid>
      <description>(Work In Progress) Most sequence functions in Clojure, such as map, range, filter and others, return lazy sequences. This can be used to write methods that take advantage of lazy sequences where you would normally reach for loops in other languages.
A simple example (and way to construct lazy seqs) is the Clojure function iterate. It takes a function and an initial value and will apply that function to the value, and each subsequent value produced, to generate &amp;quot;infinitely&amp;quot; many values for that sequence.</description>
    </item>
    
    <item>
      <title>( DFS )</title>
      <link>https://datamadic.github.io/posts/dfs/</link>
      <pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://datamadic.github.io/posts/dfs/</guid>
      <description>Useful for finding cycles and is often used as step in the process for things like topological sorts (as demonstrated below) and finding strongly connected components. DFS is generally run to learn about a graph&#39;s structure and, unlike BFS which is ordinarily seeded with a single root vertex, DFS will iterate over all vertices. The discovered and finished times have a parenthesis structure where the intervals \([d[u], f[u]] \:and\: [d[v], f[v]]\) are either entirely disjoint, or one is entirely contained within the other.</description>
    </item>
    
    <item>
      <title>( BFS )</title>
      <link>https://datamadic.github.io/posts/bfs/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://datamadic.github.io/posts/bfs/</guid>
      <description>Given a graph G = (V, E) and a distinguished vertex s, BFS explores the edges of G to discover every vertex that is reachable from s.
It computes the distance (smallest number of edges) from s to each reachable vertex.
It produces an breadth-first tree with root s that contains all reachable vertices. For any vertex v reachable from s, the path in the breadth-first tree from v to s corresponds to a shortest path from v to s in G.</description>
    </item>
    
  </channel>
</rss>